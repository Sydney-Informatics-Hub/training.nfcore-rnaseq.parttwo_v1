---
title: "Count-matrix to DE genes in R"
teaching: 10
exercises: 10
questions:
- "How to import a count-matrix (output from nfcore) in R?"
- "How to generate PCA/Scree plots for exploring multivariate data?"
- "How to use the DESeq2 module to perform differential expression (DE) analysis?"
- "How to visualise the results from DeSeq2 analysis?" 


objectives:
- "Use RStudio on Nimbus instance to process the count-matrix and generate a list of differentially expressed genes."

keypoints:
- XXX
---


- The first step when working in the R environment is to set up the path to your current working directory.
- The RStudio IDE instance which we plan to use to run the R code is a container instance which has been set up with pre-installed R-libraries.
- We just need to load these R-libraries and use them for our analysis.
- In case, a particular R-library is found not installed on the VM instance, we can search for it's installation instructions and install it during the session. 

> ## Working directory and R-libraries
> ```
> # Set the working directory
> current_path <- getActiveDocumentContext()$path 
> setwd(dirname(current_path ))
> # Load required R-libraries
> suppressMessages({
>   library("DESeq2")
>   library("edgeR")
>   library("limma")
>   library("RColorBrewer")
>   library("gplots")
>   library("ggplot2")
>   library("EnhancedVolcano")
>  library("factoextra")
>   library("devtools")
>   library("rstudioapi")
>   library("dplyr")
>   library("tibble")
>   library("tidyverse")
>   library("pheatmap")
>   library("biomaRt")
>   library("annotables")
>   library("org.Mm.eg.db")
>   library("biobroom")
>   library("clusterProfiler")
>   #library("pathfindR")
> })
> ```
> {: .language-bash}
{: .solution}


### Input to R 
- The DESeq2 package expects count data from RNA-seq or another high-throughput sequencing experiment in the form of a matrix of integer values, as input. 
  - The value in the i-th row and the j-th column of the matrix tells how many reads can be assigned to gene i in sample j. 
  - The values in the matrix should be un-normalized counts or estimated counts of sequencing reads (for single-end RNA-seq) or fragments (for paired-end RNA-seq). 
  - The DESeq2 model internally corrects for library size, so transformed or normalized values such as counts scaled by library size should NOT be used as input.
- Next, we read in the count matrix generated by the "nfcore-rnaseq" pipeline.
  - We have generated a matrix for a sub-set of the data from a specific region of the genome (chromosome 18). This was done with consideration to the time required for mapping and other processing steps involved.
  - We will be using this processed - subset matrix as part I of our analysis. This matrix should be available in the path "/".
  - As part II of the hands-on, we will redo the analysis with a FULL matrix which has been downloaded from the original manuscript. We can then use this full data for identifying gene functional categories of interest.
  - The file containing the full matrix should be available in the same folder "/" as "GSE81082_count_matrix_ENSIDs_symbols_nr.txt". 

> ## Import the gene-count matrix
> ```
> counttable_original<-read.delim("GSE81082_count_matrix_ENSIDs_symbols_nr.txt", header=T, row.names=1) 
> # View the count matrix
> #View(counttable_original)
> # Gene symbol as the identifier (when compared to ENSG ID)
> counttable<-counttable_original[,c("Symbol","WT1","WT2","WT3","KO1","KO2","KO3")]
> row.names(counttable) <- NULL
> # Convert Column  'GeneSymbol' to rowname)
> rownames(counttable) <- counttable$Symbol
> counttable<-counttable[,c("WT1","WT2","WT3","KO1","KO2","KO3")]
> #View(counttable)
> ```
> {: .language-bash}
{: .solution}


### DESeq2 object
- The object class used by the DESeq2 package is the DESeqDataSet.
- The DESeqDataSet object is used to store the read counts and the intermediate estimated quantities during statistical analysis 
- We will call this object by name 'dds' as this is a standard practice.
- Please see the [guide](http://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) for more package information.
- We will  define a condition variable to associate the individual columns (samples) in the matrix to their appropriate experimental condition (either 'Wild-type' or 'Knockout').
- We will then prepare the DESeq2 object with `design = ~1`. 
- A design of ~1 is used for no experimental design and is useful for exploring QC of the data (not for identifying differentially expressed -DE genes).

> ## The DESeqDataSet object (for exploration)
> ```
> #Define a condition variable 
> condition=c("Wild","Wild","Wild","KO","KO","KO")
> meta <- data.frame(row.names=colnames(counttable),condition)
> #View(meta)
> dds <- DESeqDataSetFromMatrix(countData = counttable, 
                              colData = meta, 
                              design = ~1)
> ```
> {: .language-bash}
{: .solution}


### Data transformations
- For visualization or clustering it might be useful to work with transformed versions of the count data.
- The most obvious choice of transformation is the logarithm.
- (1) Variance stabilizing transformation (vst)
- (2) Regularized log transformation (rlog)
- This transforms the raw count data (which is heteroskedatic - variance grows with the mean) into homoskedatic data (variance is not dependant on the mean). 
- Both methods produce data on the log2 scale, and normalize for other factors such as library size. Setting `blind=TRUE` (the default) should be used to compare samples in a manner wholly unbiased about the information about experimental groups, for example to perform sample QC. 
- Note : In order to test for differential expression, we operate on raw counts (and not normalized/transformed counts).

> ## Variance stabilisting transformation (VST)
> ```
> #VST by default uses a subset of 1000 rows to estimate the dispersion trend. This method is much faster than rlog, and is recommended if you have hundreds of samples.
> vst <- vst(dds, blind = TRUE)
> vst.data <- assay(vst)
> # Regularized log (rlog) takes a long time with 50 or more samples
> # rld <- rlog(dds, blind=FALSE)
> ```
> {: .language-bash}
{: .solution}

### Sample-to-sample distances
- A heatmap of this distance matrix gives us an overview over similarities and dissimilarities between samples. 
- We have to provide a hierarchical clustering hc to the heatmap function based on the sample distances, or else the heatmap function would calculate a clustering based on the distances between the rows/columns of the distance matrix.

> ## Heatmap to show sample-distances
> ```
> sampleDists <- dist(t(assay(vst)))
> sampleDistMatrix <- as.matrix(sampleDists)
> rownames(sampleDistMatrix) <- paste(vst$condition, vst$type, sep="-")
> colnames(sampleDistMatrix) <- NULL
> colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
> pheatmap(sampleDistMatrix,
>          clustering_distance_rows=sampleDists,
>          clustering_distance_cols=sampleDists,
>          col=colors)
> ```
> {: .language-bash}
{: .solution}


### Differential expression 
- A DESeqDataSet object must have an associated design formula. 
  - The design formula expresses the variables which will be used in modeling. 
  - The formula should be a tilde (~) followed by the variables with plus signs between them.
  - The design can be changed later, however then all differential analysis steps should be repeated, as the design formula is used to estimate the dispersions and to estimate the log2 fold changes of the model.
- There are multiple ways of constructing a DESeqDataSet, depending on what pipeline was used upstream of DESeq2 to generated counts or estimated counts
  - Here we have a matrix (as read in a dataframe above) of read counts prepared from our previous analysis using nfcore-rnaseq pipeline.
  - So we use have used the function - DESeqDataSetFromMatrix

> ## The DESeqDataSet object (with design)
> ```
> dds <- DESeqDataSetFromMatrix(countData = counttable,
>                               colData = meta,
>                               design = ~ condition)
> # Check and discuss if required what is the warning!
> #Warning in DESeqDataSet(se, design = design, ignoreRank) :
> #  some variables in design formula are characters, converting to factors
> ```
> {: .language-bash}
{: .solution}

In the above formula we have a : 
- A count matrix (countData) called counttable 
- A table of sample information called meta. 
- The design indicates how to model the samples, here, that we want to measure the effect of the condition 
- If we are controlling for batch differences then the design can be defined as design= ~ batch + condition.
- The two factor variables batch and condition should be columns of coldata.

### Genes with low expression 
- Our count matrix may contain many rows with only zeros, and additionally many rows with only a few fragments in total
- Pre-filtering of such genes with very low counts is useful because: 
- Genes with very low counts across all samples provide little evidence for differential expression and they interfere with some of the statistical approximations that are used later in the pipeline.
- They also add to the multiple testing burden when estimating false discovery rates, reducing power to detect differentially expressed genes.

> ## Pre-filtering of gene-counts
> ```
> #How many gene rows before filtering?
> nrow(dds)
> keep <- rowSums(cpm(counttable)>1) >=4
> dds <- dds[keep,]
> # How many gene rows after filtering?
> nrow(dds)
> ```
> {: .language-bash}
{: .solution}
- NB: only XX% of the genes remain after performing this filtering step, demonstrating the degree to which our performance will be improved by discarding the non-informative entries.


### Factors levels 
- By default, R will choose a reference level for factors based on alphabetical order.
- So if you never tell the DESeq2 functions which level you want to compare against (e.g. which level represents the control group), the comparisons will be based on the alphabetical order of the levels.

> ## Explicitly set the factors levels 
> ```
> # Using factor
> #dds$condition <- factor(dds$condition, levels = c("Wild","KO"))
> #OR
> # using relevel, just specifying the reference level:
> dds$condition ~ relevel(dds$condition, ref="Wild")
> ```
> {: .language-bash}
{: .solution}


### Plots related to Principal component analysis
- A **PCA plot** shows the samples in the 2D plane spanned by their first two principal components.
- This plot is useful for visualizing the overall effect of experimental covariates and batch effects.

> ## PCA plot
> ```
> vsd <- vst(dds, blind=FALSE)
> z<-plotPCA(vsd, intgroup=c("condition"))
> z+ geom_text(aes_string(x = "PC1", y = "PC2", label = "name"),color = "black",size = 4)
> # for the subsetted data
> # There is an error with vsd (possibly due to very few rows/ genes with valid expression)
>   # https://support.bioconductor.org/p/98634/
>   # problem is that your expression matrix doesn't have more than 1000 genes (rows) in it.
> # Using rlog (regularized log) transformation is slower but it works in this case for very few genes 
> #rld <- rlog(dds)
> #z<-plotPCA(rld, intgroup=c("condition"))
> #z+ geom_text(aes_string(x = "PC1", y = "PC2", label = "name"), color = "black",size = 4)
> ```
> {: .language-bash}
{: .solution}

- A **Scree plot** is a line plot of the eigenvalues of factors or principal components in an analysis. 
- A scree plot shows the eigenvalues on the y-axis and the number of factors on the x-axis. 
- It always displays a downward curve. 
- The scree plot is used to determine the number of principal components to keep in a principal component analysis (PCA).
- The point where the slope of the curve is clearly leveling off (the “elbow) indicates the number of factors that should be generated by the analysis.

> ## Scree plot
> ```
> pca=prcomp(t(assay(vsd)),scale=FALSE)
> options(repr.plot.width=0.5, repr.plot.height=0.5)
> fviz_eig(pca, addlabels = TRUE)
> # pca
> #https://www.biostars.org/p/289196/
> ```
> {: .language-bash}
{: .solution}

### Differential expression analysis

> ## The DESeq function
> ```
> dds <- DESeq(dds)
> res <- results(dds)
> res
> # padj 0.05
> res_padj0.05<-results(dds,alpha=0.05)
> summary(res_padj0.05)
> resSig005_subset<-subset(res_padj0.05, padj < 0.05)
> write.table(resSig005_subset, "res_DeSeq2_FDR0.05_comparison_Wild_vs_KO_FUllMatrix.tab", sep="\t", col.names=NA, quote=F)
> # padj 0.1
> res_padj0.1<-results(dds,alpha=0.1)
> summary(res_padj0.1)
> resSig01_subset<-subset(res_padj0.1, padj < 0.1)
> write.table(resSig01_subset, "res_DeSeq2_FDR0.1_comparison_Wild_vs_KO_FUllMatrix.tab", sep="\t", col.names=NA, quote=F)
> # Writing normalized counts
> normalised_counts<-counts(dds,normalized=TRUE)
> write.table(normalised_counts, "normalised_all_samples_DeSeq2_FUllMatrix.tab", sep="\t", col.names=NA, quote=F)
> ```
> {: .language-bash}
{: .solution}


> ## Annotate results
> #Ordering by padj value and getting gene names for ensembl IDs.
> ```
> #grch38 comes from library(annotables)
> res_tidy.DE = tidy.DESeqResults(res)
> res_tidy.DE <- res_tidy.DE %>% arrange(p.adjusted) %>% # head(100) %>%
> inner_join(grch38, by = c(gene = "ensgene")) %>% dplyr::select(gene, 
>     baseMean, estimate, stderror, statistic, p.value, p.adjusted, symbol, description) #%>% 
> # pander::pandoc.table(split.table=100, justify='lrrll',
> # style='rmarkdown')
> res_tidy.DE
> write.table(res_tidy.DE, "res_tidy.DE_DeSeq2.txt", sep="\t", col.names=NA, quote=F)
> ```
> {: .language-bash}
{: .solution}

> ## Volcano plot
> ```
> labelNow<-paste(res_tidy.DE$symbol,res_tidy.DE$description, sep = " ", collapse = NULL)
> EnhancedVolcano(res_tidy.DE,
>     lab = labelNow,
>     x = 'estimate',
>     y = 'p.adjusted',
>     pointSize = 2.0,
>     labSize = 6.0,
>     title = 'AdultsSevere_vs_KidsMild_YEAR2020') 
>     # flip volcano on it’s side
>     # + coord_flip()
> ```
> {: .language-bash}
{: .solution}
